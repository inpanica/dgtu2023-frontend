import {
  __commonJS
} from "./chunk-WNKWOKNR.js";

// node_modules/lodash.invert/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.invert/index.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object2) {
        setter(accumulator, iteratee(value), key, object2);
      });
      return accumulator;
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var invert = createInverter(function(result, value, key) {
      result[value] = key;
    }, constant(identity));
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    module.exports = invert;
  }
});

// node_modules/cyrillic-to-translit-js/CyrillicToTranslit.js
var require_CyrillicToTranslit = __commonJS({
  "node_modules/cyrillic-to-translit-js/CyrillicToTranslit.js"(exports, module) {
    module.exports = function cyrillicToTranslit(config) {
      const invert = require_lodash();
      const _preset = config ? config.preset : "ru";
      const _firstLetters = {
        "а": "a",
        "б": "b",
        "в": "v",
        "д": "d",
        "з": "z",
        "й": "y",
        "к": "k",
        "л": "l",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "p",
        "р": "r",
        "с": "s",
        "т": "t",
        "у": "u",
        "ф": "f",
        "ь": ""
      };
      if (_preset === "ru") {
        Object.assign(_firstLetters, {
          "г": "g",
          "и": "i",
          "ъ": "",
          "ы": "i",
          "э": "e"
        });
      } else if (_preset === "uk") {
        Object.assign(_firstLetters, {
          "г": "h",
          "ґ": "g",
          "е": "e",
          "и": "y",
          "і": "i",
          "'": "",
          "’": "",
          "ʼ": ""
        });
      } else if (_preset === "mn") {
        Object.assign(_firstLetters, {
          "г": "g",
          "ө": "o",
          "ү": "u",
          "и": "i",
          "ы": "y",
          "э": "e",
          "ъ": ""
        });
      }
      let _reversedFirstLetters;
      if (_preset === "ru") {
        _reversedFirstLetters = Object.assign(invert(_firstLetters), { "i": "и", "": "" });
      } else if (_preset === "uk") {
        _reversedFirstLetters = Object.assign(invert(_firstLetters), { "": "" });
      } else if (_preset === "mn") {
        _reversedFirstLetters = Object.assign(invert(_firstLetters), { "": "" });
      }
      const _initialDigraphs = _preset === "ru" ? { "е": "ye" } : { "є": "ye", "ї": "yi" };
      const _regularDigraphs = {
        "ё": "yo",
        "ж": "zh",
        "х": "kh",
        "ц": "ts",
        "ч": "ch",
        "ш": "sh",
        "щ": "shch",
        "ю": "yu",
        "я": "ya"
      };
      const _firstDigraphs = Object.assign({}, _regularDigraphs, _initialDigraphs);
      const _reversedFirstDigraphs = Object.assign(invert(_firstDigraphs));
      const _firstAssociations = Object.assign(_firstLetters, _firstDigraphs);
      const _nonFirstLetters = Object.assign({}, _firstLetters, { "й": "i" });
      if (_preset === "ru") {
        Object.assign(_nonFirstLetters, { "е": "e" });
      } else if (_preset === "uk") {
        Object.assign(_nonFirstLetters, { "ї": "i" });
      } else if (_preset === "mn") {
        Object.assign(_nonFirstLetters, { "е": "e" });
      }
      let _reversedNonFirstLetters;
      if (_preset === "ru") {
        _reversedNonFirstLetters = Object.assign(invert(_firstLetters), {
          "i": "и",
          "y": "ы",
          "e": "е",
          "": ""
        });
      } else if (_preset === "uk") {
        _reversedNonFirstLetters = Object.assign(invert(_firstLetters), { "": "" });
      }
      let _nonInitialDigraphs = {};
      if (_preset === "uk") {
        _nonInitialDigraphs = {
          "є": "ie",
          "ю": "iu",
          "я": "ia"
        };
      }
      const _nonFirstDigraphs = Object.assign(_regularDigraphs, _nonInitialDigraphs);
      const _reversedNonFirstDigraphs = Object.assign(invert(_nonFirstDigraphs));
      const _nonFirstAssociations = Object.assign(_nonFirstLetters, _nonFirstDigraphs);
      function transform(input, spaceReplacement) {
        if (!input) {
          return "";
        }
        const normalizedInput = input.normalize();
        let newStr = "";
        let isWordBoundary = false;
        for (let i = 0; i < normalizedInput.length; i++) {
          const isUpperCaseOrWhatever = normalizedInput[i] === normalizedInput[i].toUpperCase();
          let strLowerCase = normalizedInput[i].toLowerCase();
          if (strLowerCase === " ") {
            newStr += spaceReplacement ? spaceReplacement : " ";
            isWordBoundary = true;
            continue;
          }
          let newLetter;
          if (_preset === "uk" && normalizedInput.slice(i - 1, i + 1).toLowerCase() === "зг") {
            newLetter = "gh";
          } else if (i === 0 || isWordBoundary) {
            newLetter = _firstAssociations[strLowerCase];
            isWordBoundary = false;
          } else {
            newLetter = _nonFirstAssociations[strLowerCase];
          }
          if ("undefined" === typeof newLetter) {
            newStr += isUpperCaseOrWhatever ? strLowerCase.toUpperCase() : strLowerCase;
          } else if (isUpperCaseOrWhatever) {
            newLetter.length > 1 ? newStr += newLetter[0].toUpperCase() + newLetter.slice(1) : newStr += newLetter.toUpperCase();
          } else {
            newStr += newLetter;
          }
        }
        return newStr;
      }
      function reverse(input, spaceReplacement) {
        if (!input)
          return "";
        const normalizedInput = input.normalize();
        let newStr = "";
        let isWordBoundary = false;
        let i = 0;
        while (i < normalizedInput.length) {
          const isUpperCaseOrWhatever = normalizedInput[i] === normalizedInput[i].toUpperCase();
          let strLowerCase = normalizedInput[i].toLowerCase();
          let currentIndex = i;
          if (strLowerCase === " " || strLowerCase === spaceReplacement) {
            newStr += " ";
            isWordBoundary = true;
            i++;
            continue;
          }
          let newLetter;
          let digraph = normalizedInput.slice(i, i + 2).toLowerCase();
          if (i === 0 || isWordBoundary) {
            newLetter = _reversedFirstDigraphs[digraph];
            if (newLetter) {
              i += 2;
            } else {
              newLetter = _reversedFirstLetters[strLowerCase];
              i++;
            }
            isWordBoundary = false;
          } else {
            newLetter = _reversedNonFirstDigraphs[digraph];
            if (newLetter) {
              i += 2;
            } else {
              newLetter = _reversedNonFirstLetters[strLowerCase];
              i++;
            }
          }
          if (normalizedInput.slice(currentIndex, currentIndex + 4).toLowerCase() === "shch") {
            newLetter = "щ";
            i = currentIndex + 4;
          } else if (normalizedInput.slice(currentIndex - 1, currentIndex + 2).toLowerCase() === "zgh") {
            newLetter = "г";
            i = currentIndex + 2;
          }
          if ("undefined" === typeof newLetter) {
            newStr += isUpperCaseOrWhatever ? strLowerCase.toUpperCase() : strLowerCase;
          } else {
            if (isUpperCaseOrWhatever) {
              newLetter.length > 1 ? newStr += newLetter[0].toUpperCase() + newLetter.slice(1) : newStr += newLetter.toUpperCase();
            } else {
              newStr += newLetter;
            }
          }
        }
        return newStr;
      }
      return {
        transform,
        reverse
      };
    };
  }
});
export default require_CyrillicToTranslit();
//# sourceMappingURL=cyrillic-to-translit-js.js.map
